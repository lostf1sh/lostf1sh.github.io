---
title: coding with llms for a year
date: 2025-12-28
tags: [ai, llm, coding, productivity]
excerpt: what got faster, what stayed the same, and what got harder.
---

# coding with llms for a year

using claude (and others) for code daily. here is the honest assessment.

## what got faster

**boilerplate**: generate sql schemas, api types, test setups. 10 seconds vs 10 minutes.

**searching**: "how do i configure vite for multiple entry points" returns the exact config in seconds instead of digging through docs.

**refactoring**: "rename this function and update all call sites" across 20 files. done.

**documentation**: explain what this regex does, what this error means, why this type error appears.

## what stayed the same

**architecture**: choosing between database approaches, api design patterns, library selection. llms give options but you must judge them.

**debugging**: weird runtime errors, race conditions, deployment failures. llms guess wrong as often as they guess right.

**creative work**: novel features, unique solutions, edge cases. llms remix existing patterns.

## what got harder

**reading code**: i rely on llms to explain code. without them, i struggle to parse unfamiliar codebases.

**writing from scratch**: starting a project from zero feels harder because i default to "ask first" instead of "figure it out".

**attention span**: quick answers mean less deep thinking. sometimes you need to struggle with a problem to understand it.

## the balance

i use llms for:
- repetitive tasks
- documentation lookup
- small refactors
- one-off scripts

i avoid llms for:
- security-critical code
- learning new concepts
- architectural decisions
- unfamiliar codebases

## the future

the good developers will use llms as force multipliers. the bad ones will depend on them completely.

the skill is knowing when to ask and when to figure it out yourself.

-- moli
